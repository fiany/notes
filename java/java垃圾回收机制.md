# java垃圾回收机制

## 对象被判定为垃圾的标准

- 没有被其他对象引用

## 判定对象是否为垃圾的算法

### 引用计数算法

- 通过判断对象的引用数量来决定对象是否可以被回收
- 每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1
- 任何引用计数为0的对象实例可以被当作垃圾收集

**优点：执行效率高，程序执行受影响较小 **

**缺点：无法检测出循环引用的情况，导致内存泄露**

### 可达性分析算法

**通过判断对象的引用链是否可达来决定对象是否可以被回收**

**可以作为GC Root的对象**

- 虚拟机栈中引用的对象（栈帧中的本地变量表）
- 方法区中的常量引用的对象
- 方法区中的静态属性引用的对象
- 本地方法栈中JNI（Native方法）的引用对象
- 活跃线程的引用对象

## 垃圾回收算法

### 标记-清除算法

- 碎片化

### 复制算法

- 分为对象面和空闲面

- 对象在对象面上创建
- 存活的对象被从对象面复制到空闲面
- 将对象面所有对象内存清除

#### 特点

- 解决碎片化问题
- 顺序分配内存，简单高效
- 适用于对象存活率低的场景

### 标记-整理算法

- 标记：从根集合进行扫描，对存活的对象进行标记
- 清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。

**特点**

-  避免内存的不连续性
- 不用设置两块内存互换
- 适用于存活率高的场景

### 分代收集算法

- 垃圾回收算法的组合拳
- 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
- 目的：提高JVM的回收效率

#### GC的分类

- Minor GC
- Full GC 

#### 年轻代：尽可能快速地手机掉那些生命周期短的对象

- Eden区
- 两个Survivor区

##### 对象如何晋升到老年代

- 经历一定Minor次数依然存活的对象
- Survivor区中存放不下的对象
- 新生成的大对象（-XX:+pretenuerSizeThreshold）

##### 常用的调优参数

- -XX:SurvivorRatio：Eden和Survivor的比值，默认8：1
- -XX:NewRatio：老年代和年轻代内存大小的比例
- -XX:MaxTeruringThreshold：对象从年轻代晋升到老年代经过GC次数的最大阈值

#### 老年代：存放生命周期较长的对象

- 标记-清理算法
- 标记-整理算法

##### 出发Full GC的条件

- 老年代空间不足
- 永久代空间不足（jdk1.8之前）
- CMS GC时出现promotion failed， concurrent mode failure
- Minor GC晋升到老年代的平均大小大于老年代的剩余空间
- 调用System.gc()
- 使用RMI来进行RPC或管理的JDK应用，每小时执行一次Full GC  

