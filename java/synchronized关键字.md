# synchronized关键字

## 线程安全问题的主要诱因

- 存在共享数据（也称临界资源）
- 存在多条线程共同操作这些共享数据

解决问题的根本办法：

​	同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作

## 互斥锁的特性

- 互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块（复合操作）进行访问。互斥性也称为操作的原子性。
- 可见性：必须确保在锁被释放之前，对共享变量所作的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。
- synchronized锁的不是代码，锁的都是对象。

## 锁的分类

### 获取对象锁

两种方法：

- 同步代码块（synchronized（this），synchronized（类实例对象）），所得都是小括号中的实例对象。
- 同步非静态方法（synchronized）,锁是当前对象的实例对象。

### 获取类锁

两种方法：

- 同步代码块（synchronized(类.class)）,锁的是小括号中的类的对象。
- 同步静态方法（synchronized static method）。锁的是当前对象的类对象（Class对象）。

### 重入

从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入。

 ### 对象锁和类锁的总结

1. 有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块。
2. 若锁住的是同一个对象。一个线程在访问对象的同步代码块是，另一个访问对象的同步代码块的线程会被阻塞。
3. 若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞。
4. 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的对象锁互不干扰。
5. 同一个类的不同对象的对象锁互不干扰。
6. 类锁由于也是一种特殊的对象锁，因此表现和上述1，2，3，4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的。
7. 类锁和对象锁互不干扰。  

