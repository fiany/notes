- io多路复用
  - 同一个线程同时处理多个io请求
- redis的链地址法
- redis zset使用跳跃链表而不用红黑树
  - 红黑树操作负责操作和删除需要调整树
  - 红黑树不适合做范围查询（需要使用中序遍历）
- spring中beanFactory与factoryBean的关系
  - FactoryBean 而言，这个 Bean 不是简单的 Bean ，而是一个能生产或者修饰对象生成的工厂 Bean, 它的实现与设计模式中的工厂模式和修饰器模式类似。
  - 一般情况下，Spring 通过反射机制利用 <bean> 的 class 属性指定实现类实例化 Bean ，在某些情况下，实例化 Bean 过程比较复杂，如果按照传统的方式，则需要在 <bean> 中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。 Spring 为此提供了一个 org.springframework.bean.factory.FactoryBean 的工厂类接口，用户可以通过实现该接口定制实例化 Bean 的逻辑。
- spring 如何解决循环依赖
  - Spring通过将实例化后的对象提前暴露给Spring容器中的singletonFactories，解决了循环依赖的问题。
- mysql调优方式
  - 建表时适当添加冗余字段，减少连表操作
  - 利用查询缓存，每次查询的sql一样就会适用mysql自建缓存，如果查询的时候sql会随着时间变化就无法使用到缓存
  - 经常需要在查询sql中用于where条件的字段添加索引
  - 不需要查询的列不要添加减少磁盘io
  - 利用索引覆盖，如需要查询的列都在索引中能取到就不需要回表
  - 建立联和索引时把区分度最高的列放在索引的最左边，联合索引是用的最左匹配原则，适当调整sql写法。
  - 索引下推是官方进行的优化：是在索引遍历的过程中，对索引中所包含的字段先进行判断过滤，过滤掉不符合条件的数据，减少回表的次数，在mysql5.6之前这种情况只能每条数据回表找出数据在进行列值比较。
  - 建立前缀索引：某些列字段可能中间某一部分才有区分度，可以定义一部分字符串作为索引
  - 不要在where条件字段使用函数操作会使索引失效
  - 连表时两个字段字符集不同也会使索引失效

- es分页
  - from+size浅分页：使用from偏移量，size数据大小来分页，如果es数据有多个分片，则会对每个分片取相同数量的数据，然后集合在一起再进行排序取分页数据，这种情况如果是后面较深的分页，整体会随着from的增加，系统消耗越大。
  - scroll深分页：scroll查询每次查询时会生成一次数据快照，然后根据上一次的查询的id来进行下一次查询。scroll不支持跳页查询。不能查询到实时数据。
  - search_after：在排序的基础上，基于上一笔的sort值，查询排在它之后的数据，以此来实现分页，该查询为无状态的。总是查询出es中的最新数据。同样无法进行跳转到指定页。